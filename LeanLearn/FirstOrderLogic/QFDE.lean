namespace QFDE
/-!
# The Logic QFDE
The logical vocabulary of `QFDE` is composed by the connectives `¬`, `∧`,
and `∨`, the quantifiers `∀` and `∃`, the individual variables from
**V = {vi ∶ i ∈ ℕ}**, and parentheses.

The non-logical vocabulary of a first-order language is given by its signature,
which is a pair **S = ⟨C, 𝒫⟩** such that `C` is an infinite set of individual
constants and `𝒫` is a set of predicate letters.

Each element `P` of `𝒫` is assumed to have a corresponding finite arity.

We assume the usual definitions of such syntactic notions as term, formula, bound/free
occurrence of a variable, sentence etc.

Given a signature `S`, we shall denote the set of terms generated by `S` by **Term(S)**.

Likewise, the set of formulas and the set of sentences generated by `S` will be denoted
by **Form(S)** and **Sent(S)**. `x`, `x1`, `x2` will be used as metavariables ranging
over `V`, `c`, `c₁`, `c₂`, …  as metavariables ranging over `C`, `t`, `t₁`, `t₂`, …
as metavariables ranging over **Term(S)**, and `A`, `B`, `C`, … as metavaraibles ranging
over **Form(S)**.

Given `t`, `t₁`, `t₂` ∈ **Term(S)**, we will use the notation **t(t₂/t₁)** to denote
the result of replacing every occurrence of `t₁` in `t` (if any) by `t₂`.

Similarly, **A(t/x)** will denote the formula that results by replacing every free
occurrence of `x` in `A` by `t`.

The deductive systems and the formal semantics of the logics discussed below will be
formulated exclusively in terms of sentences.

This is the reason why we assumed that languages must always have an infinite stock of
individual constants – for otherwise we could be prevented from applying some of the
quantifier rules below due to the lack of enough constants.

Definition 1. Let `S` be a signature, `c` ∈ `C`, and `A`, `B`, `C` ∈ **Sent(S)**.
The logic **QFDE** is defined over `S` by the following natural deduction rules:
-/

variable {A B C : Prop}

axiom and_I (ha : A) (hb : B) : A ∧ B

axiom and_E_left (h : A ∧ B) : A
axiom and_E_right (h : A ∧ B) : B

axiom or_I_left (ha : A) : A ∨ B
axiom or_I_right (hb : B) : A ∨ B

axiom or_E (h : A ∨ B) (ha : A → C) (hb : B → C) : C

axiom not_and_I_left (hna : ¬A) : ¬(A ∧ B)
axiom not_and_I_right (hnb : ¬B) : ¬(A ∧ B)

axiom not_and_E (h : ¬(A ∧ B)) (ha : (¬A) → C) (hb : (¬B) → C) : C

axiom not_or_I (ha : ¬A) (hb : ¬B) : ¬(A ∨ B)

axiom not_or_E_left (h : ¬(A ∨ B)) : ¬A
axiom not_or_E_right (h : ¬(A ∨ B)) : ¬B

axiom dn_intro (h : A) : ¬¬A
axiom dn_elim (h : ¬¬A) : A

variable [Inhabited α] {A : α → Prop}
variable {c : α}

axiom forall_I (h : B ∨ A c) : B ∨ ∀x, A x
axiom forall_E (h : ∀x, A x) : A c

axiom exists_I (h : A c) : ∃x, A x
axiom exists_E (he : ∃x,A x) (hc : A c → C) : C

axiom not_forall_I (h : ¬A c) : ¬(∀x,A x)
axiom not_forall_E (h : ¬∀x,A x) (hc : (¬A c) → C) : C

axiom not_exists_I (h : ¬(A c)) : (¬∃x,A x)
axiom not_exists_E (h : ¬(∃x,A x)) : ¬(A c)

end QFDE

variable [Inhabited α] {A : α → Prop}
abbrev c : α := Inhabited.default
/- Proposition 2. The usual universal generalization rule
A(c/x)
--------
∀xA

(where c occurs neither in A nor in any hypothesis on which A(c/x) depends)
can be derived in QFDE.

Proof.
-/
theorem univ_gen (h : A c) : ∀x,A x := by
  have fafc : (∀x,A x) ∨ (A c) := QFDE.or_I_right h
  have fafa : (∀x,A x) ∨ (∀x,A x) := QFDE.forall_I fafc
  apply QFDE.or_E fafa id id
  done

-- Proposition 3. Consider the following eight rules:


example (h : ∀x,¬A x) : ¬∃x, A x := by
  have nAc : ¬(A c) := QFDE.forall_E (A := (λ x ↦ ¬A x)) h
  apply QFDE.not_exists_I nAc
  done

example (h : ¬∃x,A x) : ∀x,¬(A x) := by
  have nAc : ¬A c := QFDE.not_exists_E h
  have allnornotAc : (∀x,¬A x) ∨ ¬A c := QFDE.or_I_right nAc
  have allorall : (∀x,¬A x) ∨ (∀x,¬A x) := QFDE.forall_I allnornotAc
  apply QFDE.or_E allorall id id
  done

example (h : ∃x,¬A x) : ¬∀x, A x := by
  have nAc : ¬A c := QFDE.exists_E (A := (λ x ↦ ¬A x)) h id
  have nallA : ¬∀x,A x := QFDE.not_forall_I nAc
  exact nallA
  done

example (h : ¬∀x, A x) : ∃x,¬A x := by
  have nAc : ¬A c := QFDE.not_forall_E h id
  have exnA : ∃x,¬A x := QFDE.exists_I nAc
  exact exnA
  done

example (h : ∀x,A x) : ¬ ∃x,¬A x := by
  have Ac : A c := QFDE.forall_E h
  have AcornexnA : A c ∨ (¬∃x,¬A x) := QFDE.or_I_left Ac

  have ActonexnA : (A c) → ¬∃x,¬A x := λ hAc =>
    have dndn : ¬¬A c := QFDE.dn_intro hAc
    show ¬∃x,¬A x from QFDE.not_exists_I dndn

  have nexnA : ¬∃x,¬A x := QFDE.or_E AcornexnA ActonexnA id
  exact nexnA
  done

example (h : ¬∃x,¬A x) : ∀x, A x := by
  have nnac : ¬¬A c := QFDE.not_exists_E (A := λ x ↦ ¬A x) h
  have ac : A c := QFDE.dn_elim nnac
  -- apply univ_gen ac
  have fafc : (∀x,A x) ∨ (A c) := QFDE.or_I_right ac
  have fafa : (∀x,A x) ∨ (∀x,A x) := QFDE.forall_I fafc
  apply QFDE.or_E fafa id id
  done

example (h : ∃x,A x) : ¬∀x,¬A x := by
  have ac : A c := QFDE.exists_E h id
  have nna : ¬¬A c := QFDE.dn_intro ac
  apply QFDE.not_forall_I (A := λ x ↦ ¬A x) nna
  done

example (h : ¬∀x,¬A x) : ∃x,A x := by
  have nnac : ¬¬A c:= QFDE.not_forall_E (A := λ x ↦ ¬A x) h (λ hh : ¬¬A c ↦ hh)
  have ac : A c := QFDE.dn_elim nnac
  apply QFDE.exists_I ac
  done
